# Spring security

## 1. Что такое JWT

_<https://habr.com/ru/post/340146/>_

JWT - это строка в формате `header.payload.signature`. Header и payload - это json объекты, закодированные в `Base64`.

### 1.1 Header

Хедер JWT содержит информацию о том, как должна вычисляться JWT подпись

```json
header = {
  "alg": "HS512"
}
```

Поле alg указывает на название алгоритма, используемого при создании подписи.

### 1.2 Payload

Payload - это информация, которую мы передаём с помощью JWT. Напоминаю, она закодирована в формате Base64, а значит любой желающий может её раскодировать в обычный текст, поэтому в ней **ни в коем случае нельзя передавать секретную информацию** на подобие пароля в открытом виде.

```json
payload = {
  "email": "privileged@mail.com",
  "sub": "privileged",
  "exp": 1623624949
}
```

Поля `payload`'a называются заявками (claims). Названия полей могут быть произвольными, но существуют стандартные, а именно `sub` и `exp`. `Sub` (сокращение от `subject`) - то, о чем идёт речь, в нашем случае `login` пользователя. `Exp` - время, до которого токен является валидным, в формате UNIX timestamp.

### 1.3 Signature

Подпись токена - то, благодаря чему мы можем проверить можно ли доверять тому, что закодировано в `payload`. Для её создания используется алгоритм, указанный в `header`, а так же закодированные `header` и `payload`.

```js
HMACSHA512(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret);
```

После подписания, если кто-то попытается изменить содержимое токена (к примеру, подставить другой логин), сервер увидит что `jwt` был изменён и не пропустит токен злоумышленника.

## 2. Как работает Spring Security в сервлетах

_<https://docs.spring.io/spring-security/site/docs/current/reference/html5/#servlet-architecture>_

Если смотреть на картину в целом, каждый раз когда клиентское приложение (например, сайт в браузере) отправляет запрос серверу, контейнер сервлета создаёт цепочку фильтров `FilterChain`, содержащую в себе фильтры и сервлет, которые должны обработать `HttpServletRequest`, в зависимости от запрашиваемого пути (URI).

![Filter chain. Spring Security](https://docs.spring.io/spring-security/site/docs/current/reference/html5/images/servlet/architecture/filterchain.png)

На один запрос выделяется максимум 1 сервлет, но фильтров может быть несколько. Они могут использоваться для:

- предотвращения выполнения следующих фильтров в цепи (например, если будет записан ответ в `HttpServletResponse`);
- изменения `HttpServletRequest` или `HttpServletResponse` и последующей передачи фильтрам в цепочке.

Для реализации аутентификации пользователя с помощью JWT мы будем создавать собственный фильтр, который вставим перед `UsernamePasswordAuthenticationFilter`, обрабатывающим аутентификацию через логин и пароль.

## 3. Создание авторизации для Spring Boot приложения с помощью Spring Security и JWT

Рассмотрим небольшое Spring Web приложение, представляющее собой Rest API для взаимодействия с отелями. Для его построения используется Layer архитектура: контроллер представляет собой маппинги эндпоинтов на методы сервиса, сервис реализует бизнес-логику, а репозиторий представляет доступ к хранилищу данных в виде объектов сущности `Hotel` (в данном случае хранилищем является коллекция в памяти).

Сейчас, при обращении к любому из эндпоинтов доступ есть у кого угодно. Нам необходимо это изменить, чтобы доступ к защищённым ресурсам был только у авторизованных пользователей.

### 3.1 User

Для начала, создадим сущность пользователя `User` с которой будем работать:

- дадим ей необходимые поля:
  - id;
  - username;
  - email;
  - password;
  - authorities;
- реализуем интерфейс `UserDetails`;
- пометим класс аннотацией `@Data` из Lombok;
- методы `isAccountNonExpired`, `isAccountNonLocked`, `isCredentialsNonExpired` и `isEnabled` заставим возвращать true всегда, т.к в целях демонстрации нам не нужна данная логика.

Класс `UserRole` представляет собой роль пользователя. Для реализации `UserDetails`, нужны `authorities`, которые описываются интерфейсом `GrantedAuthority`, поэтому реализуем его в классе `UserRole`. Для этого реализуем метод `getAuthority`, который будет возвращать нашу роль с префиксом `ROLE_`. Дело в том, что `authorities` описывают не только роли, но и права (чтение, запись и т.д.), поэтому для различия роли имеют такой префикс.

Теперь, когда у нас есть класс `User`, создадим репозиторий `UserRepository`, сервис `UserService` и контроллер `UserController`.

### 3.2 Spring Security Configuration

Создадим класс конфигурации spring security - `SpringConfig`. Унаследуемся от `WebSecurityConfigurerAdapter` и повесим на него аннотации `@Configuration` и `@EnableWebSecurity`. Заоверрайдим метод `configure(HttpSecurity http)`. Внутри, мы будем настраивать сам Spring Security.

Для начала включим CORS - нужен для того чтобы браузер мог получать разрешения на доступ к ресурсам сервера с сайта с доменом отличном от домена сервера и выключим CSRF, т.к мы не будем использовать куки для авторизации.

Так же выключим авторизацию при помощи логина и пароля и выключим html-форму.

При попадании на несуществующую страницу, или любом другом неотловленном эксепшене будем говорить пользователю что у него недостаточно прав (403).

Уберем менеджмент сессии, указав что она не должна иметь состояния.

Вынесем ограничение эндпоинтов в отдельный метод.

Многие туториалы по Spring Security предлагают так же определить `PasswordEncoder` как `BCryptEncoder`, но начиная со Spring Security 5, рекомендуется использовать `delegatingPasswordEncoder`, что позволит в будущем не задумываться о его реализации, так как Spring Security всегда будет предлагать наиболее актуальную реализацию (кто знает, может `BCryptEncoder` когда-то станет неактуален). В таком случае, пароли будут храниться не просто в виде строки, а вначале будет указана реализация шифровальщика, например `{bcrypt}$2a$10$bSZVORJKInZfrWvOxXy3FOwHXXdSSA.ELe9.ySSCsnSuqHEeCHIFC`.

_<https://docs.spring.io/spring-security/site/docs/current/reference/html5/#authentication-password-storage>_

Создадим класс PasswordConfig рядом и создадим в нём Bean PasswordEncoder с соответствующей реализацией.

Перед фильтром `UsernamePasswordAuthenticationFilter` вставим фильтр `JwtFilter`, который и будет заниматься чтением токенов и авторизацией пользователей.

### 3.3 Авторизация пользователей с помощью JWT

#### 3.3.1 JwtFilter

Создадим класс `JwtFilter`. Он будет наследоваться от `OncePerRequestFilter` (выполняется 1 раз за поток обработки запроса) и реализовывать метод `doFilterInternal`. Внутри метода мы берём у запроса заголовок `authorization` и парсим строку с токеном. По стандарту `RFC6750`, строка должна начинаться со слова Bearer _<https://datatracker.ietf.org/doc/html/rfc6750>_

Если токен присутствует, мы читаем из него информацию (например, логин), загружаем полную информацию о пользователе и устанавливаем контекст безопасности для запроса. Затем, делегируем обработку запроса другим фильтрам. На этом этапе, пользователь авторизован и его запрос обрабатывается в соответствии с его ролями.

У класса так же есть метод `shouldNotFilter`, который мы можем переопределить чтобы игнорировать некоторые запросы.

#### 3.3.2 JwtProvider

Для того чтобы достать из токена логин пользователя, создадим класс `JwtProvider`, который будет отвечать как за генерацию так и за чтение JWT.

Создадим метод `getLoginFromToken`. Именно в нём мы будем проверять валидность токена и его подписи.

#### 3.3.3 Конфигурация JWT

Для подписания и проверки подписи токена, нам нужно будет определить секретный ключ, который будет криптографически стойким для алгоритма шифрования. Для генерации такого ключа воспользуемся средствами библиотеки, реализующей jwt.

```java
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.io.Encoders;
import io.jsonwebtoken.security.Keys;

...

SecretKey key = Keys.secretKeyFor(SignatureAlgorithm.HS512);
String base64Key = Encoders.BASE64.encode(key.getEncoded());
System.out.println(base64Key);
```

В консоль выведется строка, зашифрованная в формате Base64, которую мы вставим в application.yml.

```yml
jwt:
  # base64 encoded key
  secret: 9i3Bk8SJ3CfqIm+v9JJjHc5PGmqNmevaXDLYX4k0sW9hmhuvA6rTNWIM6uISlbVWcn28bMs+gY+P3LLzRytHMQ==
  # 24h
  secs_to_expire: 86400
```

Здесь мы определили секретный ключ и время жизни токена. Через 24 часа токен будет просроченным и пользователю необходимо будет заново получить его.

Для того чтобы иметь доступ к этим настройкам в коде, нам нужно создать файл настроек. Для этого создадим класс `JwtProperties`, аннотируем его аннотациями `@Configuration` и `@ConfigurationProperties`, а так же добавим аннотацию `@EnableConfigurationProperties` на главный класс приложения чтобы указать Spring'у что перед запуском нужно просканировать классы на наличие файлов конфигураций.

Повесим на класс так же аннотации `@Getter` и `@Setter` из Lombok, чтобы можно было обращаться к приватным полям.

В классе `JwtProvider`, заинжектим класс с настройками, чтобы можно было прочитать секретный ключ и время жизни токена.

Так же создадим поле `JwtParser` и сделаем его инициализацию ленивой. При инициализации укажем секретный ключ.

Теперь можно применять парсер при чтении токена в методе `getLoginFromToken`. Если токен будет неправильным - будут выброшены различные исключения.

#### 3.3.4 Получение информации о пользователе в контроллере

В шаге 3.3.1 мы проверяли токен пользователя и устанавливали `SecurityContext` для запроса. Мы можем получить информацию о пользователе на уровне контроллера, для этого можно воспользоваться аннотацией `@AuthenticationPrincipal`, навешанной на аргумент, реализующий интерфейс `UserDetails`. Теперь, при отработке метода контроллера, в качестве аргумента user, будет передана информация о текущем пользователе, совершающем запрос.

Этим можно воспользоваться для авторизации пользователя на уровне бизнес-логики (например, проверить что только владелец может удалить отель).

### 3.4 Получение токена с помощью логина и пароля

Наше приложение уже умеет принимать запросы с токеном в заголовке. Создадим endpoint для получения токена с помощью логина и пароля.

В классе `AuthController` создадим `PostMapping` по пути `auth/login`. Телом запроса будет класс, содержащий поля логин и пароль.

При обращении, в классе AuthService загрузим данные пользователя по логину, а затем проверим с помощью `PasswordEncoder`'a совпадают ли зашифрованный пароль и тот, что прислал пользователь.

Если пароли совпадают - создадим токен с помощью метода нашего класса `JwtProvider`, которым ранее мы парсили содержимое токена.

В методе `generateToken` мы создадим дату, большую чем наша на количество секунд, равное жизни токена. Так же в нём мы укажем логин пользователя, а так же подпишем токен ключом, который использовали для парсинга логина.

### 3.5 Настройка доступа к эндпоинтам в зависимости от роли пользователя

В классе `SecurityConfig` определим какие пути будут доступны каким пользователям.

Для получения информации об отелях не нужно быть авторизованным, а для их редактирования нужно иметь роль администратора или пользователя.

Для получения информации обо всех пользователях нужно быть администратором.

Теперь проверим работу сервера в Postman.

## 4. Создание авторизации с помощью Google и Facebook OAuth2

### 4.1 Флоу работы с OAuth2 провайдером

На диаграмме нарисован флоу авторизации клиента с помощью OAuth2 провайдера Google.

![Флоу работы с Google](https://i.imgur.com/4114FGV.png)

Давайте разберёмся что здесь происходит.

Наше клиентское приложение переходит по ссылке на наш сервер, которая триггерит авторизацию с помощью Google. В ссылке передаётся query-переменная `redirect_uri`, на которую мы хотим получить JWT токен авторизации после успешной авторизации через Google.

На сервере мы сохраняем `redirect_uri` в httpOnly куки и редиректим клиентское приложение на сервер Google. Теперь у нас в браузере окно авторизации Google, где мы указываем наши данные от аккаунта Google. После успешной авторизации, Google редиректит нас на сервер.

Сервер, получив запрос с успешной авторизацией и информацией о пользователе, проверяет есть ли в куках `redirect_uri` и проверяет ссылку на соответствие с доверенными ссылками. Если этого не проверить, кто угодно сможет получить наш токен со своего сайта (например, указав вместо `https://ourwebsite.com/oauth2/google?redirect_uri=ourwebsite.com` `https://ourwebsite.com/oauth2/google?redirect_uri=malicious_website.com`). Когда сервер понимает что ссылка валидная, он редиректит браузер обратно на изначальную `redirect_uri`, но дописывает в url query параметр `token`, содержащий значение JWT для дальнейшей работы с сервером.

### 4.2 Конфигурация Spring Security

Для работы с oauth2, добавим в зависимости `spring-boot-starter-oauth2-client`. Она облегчит нам коммуникацию с провайдерами на подобие Google и Facebook.

#### 4.2.1 Конфигурация входящей точки oauth2 запроса

Настроим конфигурационные классы для oauth. Для начала, в классе SecurityConfig укажем что эндроинт для начала авторизации с помощью oauth2 будет по ссылке `/auth/oauth2/authorize`, а так же модифицируем репозиторий чтобы сохранить `redirection_uri` в httpOnly куки.

Создадим `@Bean` `AuthorizationRequestRepository` внутри SecurityConfig и сам класс, который назовём `RedirectUriToCookiePersister`

Внутри нашего класса воспользуемся композицией чтобы унаследовать поведение класса `HttpSessionOAuth2AuthorizationRequestRepository`, так как он является дефолтным и мы не хотим ничего менять в его поведении, только добавить своё.

В методе `saveAuthorizationRequest` прочтём `redirect_uri` из query запроса и запишем его в куки.

#### 4.2.2 Конфигурация эндпоинта перенаправления после ввода креденшиалов Google

В redirectionEndpoint укажем baseUri для перенаправления после ввода креденшиалов Google. В properties.yml нам нужно будет указать такую же redirectUri. Т.е если в redirectionEndpoint baseUri у нас `/auth/oauth2/code/*`, то в properties.yml redirectUri будет `{baseUrl}/auth/oauth2/code/{registrationId}`

#### 4.2.3 ч1. Конфигурация в случае успешной авторизации

В случае успешной авторизации через Google, нам нужно преобразовать информацию, которую нам вернёт провайдер в полноценного пользователя. Для этого создадим класс `SimpleOAuth2UserService` и унаследуемся от `DefaultOAuth2UserService` для переопределения логики загрузки пользователя.

Из аргументов провайдера достанем почту и попытаемся найти по ней пользователя. Если он был найден, просто вернём его. Если такого пользователя раньше не было - создадим его и вернём.

#### 4.2.3 ч2. Конфигурация в случае успешной авторизации

Вернёмся к настройке `SecurityConfig`. После того как пользователь был загружен, нам нужно вернуть токен клиентскому приложению. Создадим класс `SimpleOAuth2SuccessHandler` и унаследуем его от `SimpleUrlAuthenticationSuccessHandler`. Этот класс в случае успеха редиректит пользователя на дефолтную ссылку. Переопределим метод `determineTargetUrl`, ведь именно на ссылку из этого метода сервер будет нас редиректить.

Достанем redirect_uri куки из запроса и проверим является ли данный uri разрешённым. Если так и есть - вернём ссылку redirect_uri, добавив к ней в url JWT токен.

#### 4.2.4 Конфигурация секретных ключей для Google и Facebook

#### Конфигурация Google

1. Для начала перейдём по ссылке <https://console.cloud.google.com/apis/dashboard> и создадим аккаунт приложения.
2. Затем, перейдём в боковой панели на вкладку Credentials и найдём сверху кнопку `+ Create Credentials`.
3. Нажмём на `Create OAuth Client ID` и выберем в application type `web application`
4. Если мы хостим приложение на каком-то хостинге, нам нужно будет указать в Authorized redirect URIs ссылку на эндпоинт из шага 4.2.2 (ourHosting.com/auth/oauth2/code/google)
5. Копируем ClientID и Client Secret для Google и вставляем их в application.yml под ключами client-id и client-secret.

#### Конфигурация Facebook

1. Заходим на <https://developers.facebook.com> и создаём приложение.
2. Добавляем к нему "Вход через Facebook"
3. Выставляем настройки как на скриншоте
   ![Facebook OAuth2](https://i.imgur.com/55DMlmx.png)
4. Если хостим - в действительные URI перенаправления для OAuth указываем ссылку на эндпоинт из шага 4.2.2 (ourHosting.com/auth/oauth2/code/facebook)
5. ClientID и Client Secret узнаем на боковой вкладке Настройки > Основное.

```yml
spring:
  security:
    oauth2:
      client:
        registration:
          google:
            client-id: 11111111111-qweqwewqeqwewqewqewqewqewe.apps.googleusercontent.com
            client-secret: qweqwewqewqewqewqeqweqwe
            redirectUri: "{baseUrl}/auth/oauth2/code/{registrationId}"
            scope:
              - email
              - profile
          facebook:
            clientId: 11111111111111
            clientSecret: qweqwewqeqweqwewqeqwewqewqeqwewqe
            redirectUri: "{baseUrl}/auth/oauth2/code/{registrationId}"
            scope:
              - email
              - public_profile
```

### 4.3 Использование OAuth2 на клиентском React приложении

Для демонстрации работы OAuth2, создадим ссылки в приложении React, которые будут вести на эндпоинты сервера с авторизацией через соцсети, например:

`http://localhost:8082/auth/oauth2/authorize/google?redirect_uri=http://localhost:3000/oauth2/resolve`

После успешной авторизации, сервер перенаправит нас на `http://localhost:3000/oauth2/resolve` с токеном в query: `http://localhost:3000/oauth2/resolve?token=qweqwewqewqeqweqweqwe`

## Конец :)
